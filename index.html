<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumina - Interactive Generative Art</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --ui-bg: rgba(0, 0, 0, 0.7);
            --ui-bg-hover: rgba(255, 255, 255, 0.1);
            --ui-border: rgba(255, 255, 255, 0.1);
            --ui-text: rgba(255, 255, 255, 0.9);
            --ui-text-muted: rgba(255, 255, 255, 0.5);
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.4);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: var(--ui-text);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* UI Container */
        .ui-container {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-container > * {
            pointer-events: auto;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.4s ease;
        }

        .header.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.6) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        /* Buttons */
        .btn {
            background: var(--ui-bg);
            border: 1px solid var(--ui-border);
            color: var(--ui-text);
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--ui-bg-hover);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .btn svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            stroke-width: 1.5;
            fill: none;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        .control-panel.hidden {
            opacity: 0;
            transform: translateY(-50%) translateX(-20px);
            pointer-events: none;
        }

        .mode-btn {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: var(--ui-bg);
            border: 1px solid var(--ui-border);
            color: var(--ui-text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .mode-btn:hover {
            background: var(--ui-bg-hover);
            color: var(--ui-text);
            transform: scale(1.05);
        }

        .mode-btn.active {
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
        }

        .mode-btn svg {
            width: 22px;
            height: 22px;
            stroke: currentColor;
            stroke-width: 1.5;
            fill: none;
        }

        .mode-tooltip {
            position: absolute;
            left: 60px;
            background: var(--ui-bg);
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.2s ease;
            pointer-events: none;
            backdrop-filter: blur(20px);
        }

        .mode-btn:hover .mode-tooltip {
            opacity: 1;
            transform: translateX(0);
        }

        /* Color Palette Panel */
        .palette-panel {
            position: fixed;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        .palette-panel.hidden {
            opacity: 0;
            transform: translateY(-50%) translateX(20px);
            pointer-events: none;
        }

        .palette-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .palette-btn:hover {
            transform: scale(1.15);
        }

        .palette-btn.active {
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .palette-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 100;
            transition: opacity 0.4s ease;
        }

        .info-panel.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .info-text {
            font-size: 0.75rem;
            color: var(--ui-text-muted);
            letter-spacing: 0.05em;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: 300;
            margin-top: 4px;
        }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: rgba(20, 20, 25, 0.95);
            border: 1px solid var(--ui-border);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            transform: scale(0.9) translateY(20px);
            transition: transform 0.3s ease;
            backdrop-filter: blur(20px);
        }

        .modal-overlay.visible .modal {
            transform: scale(1) translateY(0);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 300;
            margin-bottom: 30px;
            letter-spacing: 0.1em;
        }

        .setting-group {
            margin-bottom: 25px;
        }

        .setting-label {
            font-size: 0.8rem;
            color: var(--ui-text-muted);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: var(--ui-border);
            border-radius: 2px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider-value {
            font-size: 0.9rem;
            min-width: 40px;
            text-align: right;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        /* Keyboard Hints */
        .keyboard-hints {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            gap: 15px;
            transition: opacity 0.4s ease;
        }

        .keyboard-hints.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .hint {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            color: var(--ui-text-muted);
        }

        .hint kbd {
            background: var(--ui-bg);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.7rem;
            border: 1px solid var(--ui-border);
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 300;
        }

        .toast {
            background: var(--ui-bg);
            padding: 15px 25px;
            border-radius: 12px;
            backdrop-filter: blur(20px);
            border: 1px solid var(--ui-border);
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
        }

        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes toastOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        /* Welcome Screen */
        .welcome-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 1s ease;
        }

        .welcome-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .welcome-logo {
            font-size: 4rem;
            font-weight: 200;
            letter-spacing: 0.5em;
            text-transform: uppercase;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.4) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: welcomeFadeIn 1.5s ease;
        }

        .welcome-tagline {
            font-size: 1rem;
            color: var(--ui-text-muted);
            letter-spacing: 0.3em;
            margin-bottom: 60px;
            animation: welcomeFadeIn 1.5s ease 0.3s backwards;
        }

        .welcome-start {
            animation: welcomeFadeIn 1.5s ease 0.6s backwards;
        }

        @keyframes welcomeFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Fullscreen mode */
        body.fullscreen .header,
        body.fullscreen .control-panel,
        body.fullscreen .palette-panel,
        body.fullscreen .info-panel,
        body.fullscreen .keyboard-hints {
            opacity: 0;
            pointer-events: none;
        }

        body.fullscreen:hover .header,
        body.fullscreen:hover .control-panel,
        body.fullscreen:hover .palette-panel,
        body.fullscreen:hover .info-panel,
        body.fullscreen:hover .keyboard-hints {
            opacity: 1;
            pointer-events: auto;
        }

        /* FPS Counter */
        .fps-counter {
            position: fixed;
            top: 70px;
            left: 30px;
            font-size: 0.7rem;
            color: var(--ui-text-muted);
            font-family: monospace;
            z-index: 100;
            transition: opacity 0.4s ease;
        }

        .fps-counter.hidden {
            opacity: 0;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 15px 20px;
            }

            .logo {
                font-size: 1.2rem;
            }

            .control-panel {
                left: 15px;
            }

            .palette-panel {
                right: 15px;
            }

            .keyboard-hints {
                display: none;
            }

            .welcome-logo {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-logo">Lumina</div>
        <div class="welcome-tagline">Interactive Generative Art</div>
        <button class="btn welcome-start" id="startBtn">
            <svg viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>
            Begin Experience
        </button>
    </div>

    <!-- Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Header -->
    <header class="header" id="header">
        <div class="logo">Lumina</div>
        <div class="header-actions">
            <button class="btn" id="randomBtn">
                <svg viewBox="0 0 24 24"><path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/></svg>
                Random
            </button>
            <button class="btn" id="saveBtn">
                <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                Save
            </button>
            <button class="btn btn-icon" id="settingsBtn">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
            </button>
            <button class="btn btn-icon" id="fullscreenBtn">
                <svg viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg>
            </button>
        </div>
    </header>

    <!-- Mode Selection -->
    <div class="control-panel" id="controlPanel">
        <button class="mode-btn active" data-mode="flowField">
            <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/><path d="M12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>
            <span class="mode-tooltip">Flow Field</span>
        </button>
        <button class="mode-btn" data-mode="particles">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="2"/><circle cx="6" cy="6" r="1.5"/><circle cx="18" cy="8" r="1"/><circle cx="8" cy="18" r="1.5"/><circle cx="17" cy="17" r="1"/><circle cx="4" cy="12" r="1"/><circle cx="20" cy="14" r="1.5"/></svg>
            <span class="mode-tooltip">Particles</span>
        </button>
        <button class="mode-btn" data-mode="waves">
            <svg viewBox="0 0 24 24"><path d="M2 12c2-3 4-4 6-4s4 2 6 2 4-2 6-2 4 1 4 4"/><path d="M2 17c2-3 4-4 6-4s4 2 6 2 4-2 6-2 4 1 4 4"/><path d="M2 7c2-3 4-4 6-4s4 2 6 2 4-2 6-2 4 1 4 4"/></svg>
            <span class="mode-tooltip">Waves</span>
        </button>
        <button class="mode-btn" data-mode="aurora">
            <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
            <span class="mode-tooltip">Aurora</span>
        </button>
        <button class="mode-btn" data-mode="constellation">
            <svg viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>
            <span class="mode-tooltip">Constellation</span>
        </button>
        <button class="mode-btn" data-mode="nebula">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>
            <span class="mode-tooltip">Nebula</span>
        </button>
        <button class="mode-btn" data-mode="gravityWell">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3" fill="currentColor"/><path d="M12 2a10 10 0 0 1 0 20 10 10 0 0 1 0-20" stroke-dasharray="4 2"/><path d="M12 5a7 7 0 0 1 0 14 7 7 0 0 1 0-14" stroke-dasharray="3 2"/></svg>
            <span class="mode-tooltip">Gravity Well</span>
        </button>
    </div>

    <!-- Color Palettes -->
    <div class="palette-panel" id="palettePanel"></div>

    <!-- FPS Counter -->
    <div class="fps-counter" id="fpsCounter">60 FPS</div>

    <!-- Info Panel -->
    <div class="info-panel" id="infoPanel">
        <div class="info-text">CURRENT MODE</div>
        <div class="info-value" id="currentMode">Flow Field</div>
    </div>

    <!-- Keyboard Hints -->
    <div class="keyboard-hints" id="keyboardHints">
        <div class="hint"><kbd>Space</kbd> Pause</div>
        <div class="hint"><kbd>C</kbd> Clear</div>
        <div class="hint"><kbd>R</kbd> Random</div>
        <div class="hint"><kbd>F</kbd> Fullscreen</div>
        <div class="hint"><kbd>H</kbd> Hide UI</div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <h2 class="modal-title">Settings</h2>
            <div class="setting-group">
                <div class="setting-label">Particle Count</div>
                <div class="slider-container">
                    <input type="range" class="slider" id="particleCount" min="100" max="5000" value="1500">
                    <span class="slider-value" id="particleCountValue">1500</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Speed</div>
                <div class="slider-container">
                    <input type="range" class="slider" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
                    <span class="slider-value" id="speedValue">1.0</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Trail Length</div>
                <div class="slider-container">
                    <input type="range" class="slider" id="trailSlider" min="0" max="0.99" step="0.01" value="0.92">
                    <span class="slider-value" id="trailValue">92%</span>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Mouse Influence</div>
                <div class="slider-container">
                    <input type="range" class="slider" id="mouseInfluence" min="0" max="200" value="100">
                    <span class="slider-value" id="mouseInfluenceValue">100</span>
                </div>
            </div>
            <button class="btn" id="closeSettings" style="margin-top: 20px; width: 100%; justify-content: center;">Close</button>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // ============================================
        // LUMINA - Interactive Generative Art Engine
        // ============================================

        class Lumina {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                // State
                this.particles = [];
                this.currentMode = 'flowField';
                this.isPaused = false;
                this.isUIHidden = false;
                this.time = 0;
                this.frameCount = 0;

                // Mouse
                this.mouse = { x: 0, y: 0, px: 0, py: 0, isDown: false };

                // Settings
                this.settings = {
                    particleCount: 1500,
                    speed: 1,
                    trailOpacity: 0.92,
                    mouseInfluence: 100,
                    noiseScale: 0.003,
                    noiseSpeed: 0.0005
                };

                // Color Palettes
                this.palettes = [
                    { name: 'Aurora', colors: ['#00d4ff', '#7b2ff7', '#f107a3', '#00ff88'], bg: '#0a0a15' },
                    { name: 'Sunset', colors: ['#ff6b6b', '#feca57', '#ff9ff3', '#54a0ff'], bg: '#1a0a15' },
                    { name: 'Ocean', colors: ['#0077b6', '#00b4d8', '#90e0ef', '#caf0f8'], bg: '#03071e' },
                    { name: 'Forest', colors: ['#2d6a4f', '#40916c', '#52b788', '#95d5b2'], bg: '#0a1510' },
                    { name: 'Neon', colors: ['#f72585', '#7209b7', '#3a0ca3', '#4cc9f0'], bg: '#0d0221' },
                    { name: 'Ember', colors: ['#ff4800', '#ff5400', '#ff6000', '#ff7900'], bg: '#150a05' },
                    { name: 'Arctic', colors: ['#caf0f8', '#ade8f4', '#90e0ef', '#48cae4'], bg: '#0a1520' },
                    { name: 'Lavender', colors: ['#e0aaff', '#c77dff', '#9d4edd', '#7b2cbf'], bg: '#10051a' }
                ];
                this.currentPalette = 0;

                // Perlin noise implementation
                this.permutation = this.generatePermutation();

                this.init();
            }

            init() {
                this.resize();
                this.createPaletteButtons();
                this.bindEvents();
                this.createParticles();

                // Start welcome screen
                document.getElementById('startBtn').addEventListener('click', () => this.startExperience());
            }

            startExperience() {
                const welcome = document.getElementById('welcomeScreen');
                welcome.classList.add('fade-out');
                setTimeout(() => {
                    welcome.style.display = 'none';
                    this.animate();
                }, 1000);
            }

            resize() {
                const dpr = window.devicePixelRatio || 1;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width * dpr;
                this.canvas.height = this.height * dpr;
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';
                this.ctx.scale(dpr, dpr);

                // Reinitialize particles on resize
                if (this.particles.length > 0) {
                    this.createParticles();
                }
            }

            createPaletteButtons() {
                const panel = document.getElementById('palettePanel');
                this.palettes.forEach((palette, i) => {
                    const btn = document.createElement('button');
                    btn.className = `palette-btn ${i === 0 ? 'active' : ''}`;
                    btn.style.background = `linear-gradient(135deg, ${palette.colors.join(', ')})`;
                    btn.title = palette.name;
                    btn.addEventListener('click', () => this.setPalette(i));
                    panel.appendChild(btn);
                });
            }

            setPalette(index) {
                this.currentPalette = index;
                document.querySelectorAll('.palette-btn').forEach((btn, i) => {
                    btn.classList.toggle('active', i === index);
                });
                // Update particle colors
                this.particles.forEach(p => {
                    p.color = this.getRandomColor();
                });
            }

            getRandomColor() {
                const colors = this.palettes[this.currentPalette].colors;
                return colors[Math.floor(Math.random() * colors.length)];
            }

            createParticles() {
                this.particles = [];
                for (let i = 0; i < this.settings.particleCount; i++) {
                    this.particles.push(this.createParticle());
                }
            }

            createParticle(x, y) {
                return {
                    x: x !== undefined ? x : Math.random() * this.width,
                    y: y !== undefined ? y : Math.random() * this.height,
                    vx: 0,
                    vy: 0,
                    size: Math.random() * 2 + 0.5,
                    color: this.getRandomColor(),
                    life: 1,
                    maxLife: Math.random() * 200 + 100,
                    age: 0
                };
            }

            bindEvents() {
                window.addEventListener('resize', () => this.resize());

                // Mouse events
                this.canvas.addEventListener('mousemove', (e) => {
                    this.mouse.px = this.mouse.x;
                    this.mouse.py = this.mouse.y;
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                this.canvas.addEventListener('mousedown', () => this.mouse.isDown = true);
                this.canvas.addEventListener('mouseup', () => this.mouse.isDown = false);
                this.canvas.addEventListener('mouseleave', () => this.mouse.isDown = false);

                // Touch events
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.mouse.px = this.mouse.x;
                    this.mouse.py = this.mouse.y;
                    this.mouse.x = touch.clientX;
                    this.mouse.y = touch.clientY;
                }, { passive: false });

                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeydown(e));

                // Mode buttons
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.setMode(btn.dataset.mode);
                    });
                });

                // Settings
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.add('visible');
                });

                document.getElementById('closeSettings').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.remove('visible');
                });

                document.getElementById('settingsModal').addEventListener('click', (e) => {
                    if (e.target.id === 'settingsModal') {
                        document.getElementById('settingsModal').classList.remove('visible');
                    }
                });

                // Sliders
                this.bindSlider('particleCount', 'particleCountValue', (v) => {
                    this.settings.particleCount = parseInt(v);
                    this.createParticles();
                    return v;
                });

                this.bindSlider('speedSlider', 'speedValue', (v) => {
                    this.settings.speed = parseFloat(v);
                    return v.toFixed(1);
                });

                this.bindSlider('trailSlider', 'trailValue', (v) => {
                    this.settings.trailOpacity = parseFloat(v);
                    return Math.round(v * 100) + '%';
                });

                this.bindSlider('mouseInfluence', 'mouseInfluenceValue', (v) => {
                    this.settings.mouseInfluence = parseInt(v);
                    return v;
                });

                // Save button
                document.getElementById('saveBtn').addEventListener('click', () => this.saveImage());

                // Random button
                document.getElementById('randomBtn').addEventListener('click', () => this.randomize());

                // Fullscreen
                document.getElementById('fullscreenBtn').addEventListener('click', () => this.toggleFullscreen());
            }

            bindSlider(sliderId, valueId, callback) {
                const slider = document.getElementById(sliderId);
                const valueEl = document.getElementById(valueId);
                slider.addEventListener('input', () => {
                    valueEl.textContent = callback(slider.value);
                });
            }

            handleKeydown(e) {
                switch(e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        this.isPaused = !this.isPaused;
                        this.showToast(this.isPaused ? 'Paused' : 'Resumed');
                        break;
                    case 'c':
                        this.clear();
                        this.showToast('Canvas cleared');
                        break;
                    case 'f':
                        this.toggleFullscreen();
                        break;
                    case 'h':
                        this.toggleUI();
                        break;
                    case 's':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            this.saveImage();
                        }
                        break;
                    case 'r':
                        this.randomize();
                        break;
                    case '1': case '2': case '3': case '4': case '5': case '6': case '7':
                        const modeIndex = parseInt(e.key) - 1;
                        const modes = ['flowField', 'particles', 'waves', 'aurora', 'constellation', 'nebula', 'gravityWell'];
                        if (modes[modeIndex]) {
                            this.setMode(modes[modeIndex]);
                            document.querySelectorAll('.mode-btn').forEach((btn, i) => {
                                btn.classList.toggle('active', i === modeIndex);
                            });
                        }
                        break;
                }
            }

            randomize() {
                // Random mode
                const modes = ['flowField', 'particles', 'waves', 'aurora', 'constellation', 'nebula', 'gravityWell'];
                const randomMode = modes[Math.floor(Math.random() * modes.length)];
                this.setMode(randomMode);
                document.querySelectorAll('.mode-btn').forEach((btn) => {
                    btn.classList.toggle('active', btn.dataset.mode === randomMode);
                });

                // Random palette
                const randomPalette = Math.floor(Math.random() * this.palettes.length);
                this.setPalette(randomPalette);

                // Random settings
                this.settings.speed = 0.5 + Math.random() * 2;
                this.settings.trailOpacity = 0.85 + Math.random() * 0.1;
                this.settings.mouseInfluence = 50 + Math.random() * 150;

                // Update sliders
                document.getElementById('speedSlider').value = this.settings.speed;
                document.getElementById('speedValue').textContent = this.settings.speed.toFixed(1);
                document.getElementById('trailSlider').value = this.settings.trailOpacity;
                document.getElementById('trailValue').textContent = Math.round(this.settings.trailOpacity * 100) + '%';
                document.getElementById('mouseInfluence').value = this.settings.mouseInfluence;
                document.getElementById('mouseInfluenceValue').textContent = Math.round(this.settings.mouseInfluence);

                this.showToast('Randomized!');
            }

            setMode(mode) {
                this.currentMode = mode;
                this.clear();
                this.createParticles();

                const modeNames = {
                    flowField: 'Flow Field',
                    particles: 'Particles',
                    waves: 'Waves',
                    aurora: 'Aurora',
                    constellation: 'Constellation',
                    nebula: 'Nebula',
                    gravityWell: 'Gravity Well'
                };

                document.getElementById('currentMode').textContent = modeNames[mode];
                this.showToast(`Mode: ${modeNames[mode]}`);
            }

            clear() {
                this.ctx.fillStyle = this.palettes[this.currentPalette].bg;
                this.ctx.fillRect(0, 0, this.width, this.height);
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(() => {});
                    document.body.classList.add('fullscreen');
                } else {
                    document.exitFullscreen();
                    document.body.classList.remove('fullscreen');
                }
            }

            toggleUI() {
                this.isUIHidden = !this.isUIHidden;
                const elements = ['header', 'controlPanel', 'palettePanel', 'infoPanel', 'keyboardHints', 'fpsCounter'];
                elements.forEach(id => {
                    document.getElementById(id).classList.toggle('hidden', this.isUIHidden);
                });
            }

            saveImage() {
                const link = document.createElement('a');
                link.download = `lumina-${Date.now()}.png`;
                link.href = this.canvas.toDataURL('image/png');
                link.click();
                this.showToast('Image saved!');
            }

            showToast(message) {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                container.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }

            // Perlin Noise Implementation
            generatePermutation() {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }
                return [...p, ...p];
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(a, b, t) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.permutation[X] + Y;
                const B = this.permutation[X + 1] + Y;
                return this.lerp(
                    this.lerp(this.grad(this.permutation[A], x, y), this.grad(this.permutation[B], x - 1, y), u),
                    this.lerp(this.grad(this.permutation[A + 1], x, y - 1), this.grad(this.permutation[B + 1], x - 1, y - 1), u),
                    v
                );
            }

            // Mode-specific updates
            updateFlowField(particle) {
                const noiseVal = this.noise(
                    particle.x * this.settings.noiseScale,
                    particle.y * this.settings.noiseScale + this.time * this.settings.noiseSpeed
                );
                const angle = noiseVal * Math.PI * 4;

                particle.vx += Math.cos(angle) * 0.3;
                particle.vy += Math.sin(angle) * 0.3;

                // Mouse influence
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.settings.mouseInfluence) {
                    const force = (1 - dist / this.settings.mouseInfluence) * 0.5;
                    if (this.mouse.isDown) {
                        particle.vx += dx * force * 0.01;
                        particle.vy += dy * force * 0.01;
                    } else {
                        particle.vx -= dx * force * 0.005;
                        particle.vy -= dy * force * 0.005;
                    }
                }

                particle.vx *= 0.98;
                particle.vy *= 0.98;

                const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                if (speed > 4) {
                    particle.vx = (particle.vx / speed) * 4;
                    particle.vy = (particle.vy / speed) * 4;
                }
            }

            updateParticles(particle) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const dx = centerX - particle.x;
                const dy = centerY - particle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const angle = Math.atan2(dy, dx) + Math.PI / 2 + Math.sin(this.time * 0.001 + dist * 0.01) * 0.5;

                particle.vx += Math.cos(angle) * 0.1;
                particle.vy += Math.sin(angle) * 0.1;

                // Gravity toward center
                particle.vx += dx * 0.00005;
                particle.vy += dy * 0.00005;

                // Mouse repulsion
                const mdx = this.mouse.x - particle.x;
                const mdy = this.mouse.y - particle.y;
                const mdist = Math.sqrt(mdx * mdx + mdy * mdy);

                if (mdist < this.settings.mouseInfluence) {
                    const force = (1 - mdist / this.settings.mouseInfluence) * 2;
                    particle.vx -= mdx * force * 0.01;
                    particle.vy -= mdy * force * 0.01;
                }

                particle.vx *= 0.97;
                particle.vy *= 0.97;
            }

            updateWaves(particle) {
                const wave1 = Math.sin(particle.x * 0.02 + this.time * 0.002) * 20;
                const wave2 = Math.sin(particle.y * 0.015 + this.time * 0.003) * 15;
                const wave3 = Math.cos((particle.x + particle.y) * 0.01 + this.time * 0.001) * 10;

                particle.vy = (wave1 + wave2 + wave3) * 0.05;
                particle.vx = Math.cos(particle.y * 0.01 + this.time * 0.001) * 0.5;

                // Mouse creates ripples
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.settings.mouseInfluence * 1.5) {
                    const ripple = Math.sin(dist * 0.1 - this.time * 0.01) * (1 - dist / (this.settings.mouseInfluence * 1.5));
                    particle.vy += ripple * 2;
                }
            }

            updateAurora(particle) {
                const baseY = this.height * 0.3 + Math.sin(particle.x * 0.005 + this.time * 0.001) * 100;
                const targetY = baseY + Math.sin(particle.x * 0.01 + this.time * 0.002) * 50;

                particle.vy += (targetY - particle.y) * 0.01;
                particle.vx += Math.sin(this.time * 0.001 + particle.y * 0.01) * 0.1;

                // Shimmer effect
                particle.life = 0.5 + Math.sin(particle.x * 0.02 + this.time * 0.003) * 0.3;

                // Mouse creates disturbance
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.settings.mouseInfluence) {
                    const force = (1 - dist / this.settings.mouseInfluence);
                    particle.vx += dx * force * 0.005;
                    particle.vy -= Math.abs(dy) * force * 0.01;
                }

                particle.vx *= 0.98;
                particle.vy *= 0.95;
            }

            updateConstellation(particle) {
                // Gentle floating
                particle.vx += (Math.random() - 0.5) * 0.02;
                particle.vy += (Math.random() - 0.5) * 0.02;

                // Slow down
                particle.vx *= 0.99;
                particle.vy *= 0.99;

                // Mouse attracts
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < this.settings.mouseInfluence * 2) {
                    const force = (1 - dist / (this.settings.mouseInfluence * 2)) * 0.02;
                    particle.vx += dx * force;
                    particle.vy += dy * force;
                }
            }

            updateNebula(particle) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const dx = particle.x - centerX;
                const dy = particle.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                // Spiral motion
                const spiralSpeed = 0.001 + (1 - Math.min(dist / 300, 1)) * 0.002;
                const newAngle = angle + spiralSpeed * this.settings.speed;

                const noise = this.noise(particle.x * 0.005, particle.y * 0.005 + this.time * 0.0001);
                const targetDist = dist + noise * 20;

                const targetX = centerX + Math.cos(newAngle) * targetDist;
                const targetY = centerY + Math.sin(newAngle) * targetDist;

                particle.vx += (targetX - particle.x) * 0.02;
                particle.vy += (targetY - particle.y) * 0.02;

                // Mouse creates vortex
                const mdx = this.mouse.x - particle.x;
                const mdy = this.mouse.y - particle.y;
                const mdist = Math.sqrt(mdx * mdx + mdy * mdy);

                if (mdist < this.settings.mouseInfluence) {
                    const force = (1 - mdist / this.settings.mouseInfluence);
                    const mangle = Math.atan2(mdy, mdx) + Math.PI / 2;
                    particle.vx += Math.cos(mangle) * force * 0.5;
                    particle.vy += Math.sin(mangle) * force * 0.5;
                }

                particle.vx *= 0.95;
                particle.vy *= 0.95;
            }

            updateGravityWell(particle) {
                // Multiple gravity wells that orbit around center
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const wellCount = 3;
                const wellRadius = Math.min(this.width, this.height) * 0.25;

                for (let i = 0; i < wellCount; i++) {
                    const wellAngle = (this.time * 0.001) + (i * Math.PI * 2 / wellCount);
                    const wellX = centerX + Math.cos(wellAngle) * wellRadius;
                    const wellY = centerY + Math.sin(wellAngle) * wellRadius;

                    const dx = wellX - particle.x;
                    const dy = wellY - particle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Gravity pull (stronger when closer)
                    if (dist > 5) {
                        const force = 50 / (dist * dist) * 10;
                        particle.vx += (dx / dist) * force;
                        particle.vy += (dy / dist) * force;
                    }
                }

                // Add some orbital tendency
                const cdx = particle.x - centerX;
                const cdy = particle.y - centerY;
                const cangle = Math.atan2(cdy, cdx);
                particle.vx += Math.cos(cangle + Math.PI / 2) * 0.05;
                particle.vy += Math.sin(cangle + Math.PI / 2) * 0.05;

                // Mouse creates additional gravity well
                const mdx = this.mouse.x - particle.x;
                const mdy = this.mouse.y - particle.y;
                const mdist = Math.sqrt(mdx * mdx + mdy * mdy);

                if (mdist < this.settings.mouseInfluence * 2 && mdist > 5) {
                    const mforce = this.mouse.isDown ? 100 : 30;
                    const force = mforce / (mdist * mdist) * 10;
                    particle.vx += (mdx / mdist) * force;
                    particle.vy += (mdy / mdist) * force;
                }

                // Damping
                particle.vx *= 0.98;
                particle.vy *= 0.98;

                // Speed limit
                const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                if (speed > 8) {
                    particle.vx = (particle.vx / speed) * 8;
                    particle.vy = (particle.vy / speed) * 8;
                }
            }

            updateParticle(particle) {
                switch (this.currentMode) {
                    case 'flowField': this.updateFlowField(particle); break;
                    case 'particles': this.updateParticles(particle); break;
                    case 'waves': this.updateWaves(particle); break;
                    case 'aurora': this.updateAurora(particle); break;
                    case 'constellation': this.updateConstellation(particle); break;
                    case 'nebula': this.updateNebula(particle); break;
                    case 'gravityWell': this.updateGravityWell(particle); break;
                }

                particle.x += particle.vx * this.settings.speed;
                particle.y += particle.vy * this.settings.speed;

                // Wrap around screen
                if (particle.x < 0) particle.x = this.width;
                if (particle.x > this.width) particle.x = 0;
                if (particle.y < 0) particle.y = this.height;
                if (particle.y > this.height) particle.y = 0;

                particle.age++;
                if (this.currentMode !== 'aurora') {
                    particle.life = Math.max(0, 1 - particle.age / particle.maxLife);
                }
            }

            drawParticle(particle) {
                const alpha = particle.life * 0.8;
                this.ctx.fillStyle = particle.color;
                this.ctx.globalAlpha = alpha;

                if (this.currentMode === 'constellation') {
                    // Draw as star
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size * 1.5, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Glow effect
                    this.ctx.globalAlpha = alpha * 0.3;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size * 4, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (this.currentMode === 'aurora') {
                    // Vertical streaks
                    const gradient = this.ctx.createLinearGradient(
                        particle.x, particle.y - 30,
                        particle.x, particle.y + 60
                    );
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(0.3, particle.color);
                    gradient.addColorStop(0.7, particle.color);
                    gradient.addColorStop(1, 'transparent');

                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(particle.x - particle.size / 2, particle.y - 30, particle.size, 90);
                } else {
                    // Regular particle
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.ctx.globalAlpha = 1;
            }

            drawConnections() {
                if (this.currentMode !== 'constellation') return;

                const maxDist = 100;
                this.ctx.strokeStyle = this.palettes[this.currentPalette].colors[0];
                this.ctx.lineWidth = 0.5;

                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const dx = this.particles[i].x - this.particles[j].x;
                        const dy = this.particles[i].y - this.particles[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < maxDist) {
                            this.ctx.globalAlpha = (1 - dist / maxDist) * 0.3;
                            this.ctx.beginPath();
                            this.ctx.moveTo(this.particles[i].x, this.particles[i].y);
                            this.ctx.lineTo(this.particles[j].x, this.particles[j].y);
                            this.ctx.stroke();
                        }
                    }
                }
                this.ctx.globalAlpha = 1;
            }

            animate() {
                // FPS tracking
                const now = performance.now();
                if (!this.lastFrameTime) this.lastFrameTime = now;
                if (!this.fpsFrames) this.fpsFrames = 0;
                if (!this.lastFpsUpdate) this.lastFpsUpdate = now;

                this.fpsFrames++;
                if (now - this.lastFpsUpdate >= 500) {
                    const fps = Math.round(this.fpsFrames / ((now - this.lastFpsUpdate) / 1000));
                    document.getElementById('fpsCounter').textContent = `${fps} FPS`;
                    this.fpsFrames = 0;
                    this.lastFpsUpdate = now;
                }
                this.lastFrameTime = now;

                if (!this.isPaused) {
                    // Trail effect
                    this.ctx.fillStyle = this.palettes[this.currentPalette].bg;
                    this.ctx.globalAlpha = 1 - this.settings.trailOpacity;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.ctx.globalAlpha = 1;

                    // Update and draw particles
                    this.particles.forEach(p => {
                        this.updateParticle(p);
                        this.drawParticle(p);

                        // Respawn dead particles
                        if (p.age > p.maxLife && this.currentMode !== 'aurora') {
                            Object.assign(p, this.createParticle());
                        }
                    });

                    // Draw connections for constellation mode
                    this.drawConnections();

                    this.time++;
                    this.frameCount++;
                }

                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            window.lumina = new Lumina();
        });
    </script>
</body>
</html>
